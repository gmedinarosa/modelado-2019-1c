

/**
 * Makes a series of replacements on MathQuill-generated LaTeX strings so that
 * they can be parsed by MathJS.
 *
 * Notes:
 *  1. This is pretty heuristic. Might discover updates needed.
 *  2. Much of this could be used to preprocess LaTeX generated by other means
 * (i.e., not MathQuill.) The main bit that is MathQuill-specific is probably
 * the operatorname replacements.
 *
 * @param  {string} fromMQ a MathQuill-generated LaTeX expression
 * @return {string} the input expression with LaTeX commands converted to mathjs
 */
export default function mathquillToMathJS(fromMQ) {
	const replacements = [
		{ tex: '\\operatorname{diff}', mathjs: 'diff' },
		{ tex: '\\operatorname{mod}', mathjs: 'mod' },
		{ tex: '\\operatorname{abs}', mathjs: 'abs' },
		{ tex: '\\operatorname{unitT}', mathjs: 'unitT' },
		{ tex: '\\operatorname{unitN}', mathjs: 'unitN' },
		{ tex: '\\operatorname{unitB}', mathjs: 'unitB' },
		{ tex: '\\cdot', mathjs: ' * ' },
		{ tex: '\\left', mathjs: '' },
		{ tex: '\\right', mathjs: '' },
		{ tex: '{', mathjs: '(' },
		{ tex: '}', mathjs: ')' },
		{ tex: '~', mathjs: ' ' },
		{ tex: '\\', mathjs: ' ' }
	]

	// remove fractions, then apply replacements
	const noFrac = fracToDivision(fromMQ)
	return replacements.reduce(
		(acc, r) => replaceAll(acc, r['tex'], r['mathjs'] ),
		noFrac)
}

/**
 * Recursively replaces LaTeX fractions with normal divison
 *   - example: \frac{a}{1 + \frac{b}{c}} --> {a}/{1 + {b}/{c}}
 */
export function fracToDivision(expr) {
	const frac = '\\frac'
	const fracStart = expr.indexOf(frac)
	const numStart = fracStart + frac.length

	if (fracStart < 0) { return expr }

	const divIdx = findClosingBrace(expr, numStart)
	// Remove frac, and add "/"
	const newExpr = expr.slice(0, fracStart) +
		expr.slice(numStart, divIdx + 1) + '/' +
		expr.slice(divIdx + 1)

	return fracToDivision(newExpr)
}

export function escapeRegExp(str) {
	// from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_Special_Characters
	// $& means the whole matched string
	return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

export function replaceAll(str, find, replaceWith) {
	// from https://stackoverflow.com/a/1144788/2747370
	return str.replace(new RegExp(escapeRegExp(find), 'g'), replaceWith)
}

export function findClosingBrace(str, startIdx) {
	const braces = {
		'[': ']',
		'<': '>',
		'(': ')',
		'{': '}'
	}

	const openingBrace = str[startIdx]

	const closingBrace = braces[openingBrace]

	if (closingBrace === undefined) {
		throw Error(`${str} does not contain an opening brace at position ${startIdx}.`)
	}

	let stack = 1

	// eslint-disable-next-line no-plusplus
	for (let j = startIdx + 1; j < str.length; j++) {
		if (str[j] === openingBrace) {
			stack += +1
		}
		else if (str[j] === closingBrace) {
			stack += -1
		}
		if (stack === 0) {
			return j
		}
	}

	// stack !== 0
	throw Error(`${str} has a brace that opens at position ${startIdx} but does not close.`)
}